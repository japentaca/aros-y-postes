<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cabeza de pelota de Pato</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', sans-serif;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            background: rgba(0, 20, 40, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            z-index: 20;
            max-height: 90vh;
            overflow-y: auto;
        }

        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 20;
            border: 1px solid #00ff00;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #44aaff;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #44aaff;
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        #status {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #status-pill {
            display: inline-block;
            background: rgba(0, 0, 0, 0.8);
            color: #ffff00;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: monospace;
            font-size: 1.2em;
            border: 2px solid #ffff00;
        }
    </style>
</head>

<body>

    <div id="fps-counter">FPS: <span id="fps-value">0</span></div>

    <div id="controls">
        <h3 style="margin-top:0; color:#44aaff; border-bottom:1px solid #44aaff;">CONFIGURACIÓN</h3>

        <div class="control-group">
            <label>
                Modo Nocturno (Neon)
                <label class="switch">
                    <input type="checkbox" id="chk-theme">
                    <span class="slider"></span>
                </label>
            </label>
        </div>
        <div class="control-group">
            <label>Velocidad <span id="v-speed">0.25</span></label>
            <input type="range" id="sl-speed" min="0.05" max="1.5" step="0.05" value="0.25">
        </div>
        <div class="control-group">
            <label>Niebla <span id="v-fog">300</span></label>
            <input type="range" id="sl-fog" min="50" max="1000" step="50" value="300">
        </div>
        <div class="control-group">
            <label>Altura Vuelo <span id="v-height">25</span></label>
            <input type="range" id="sl-height" min="10" max="100" step="5" value="25">
        </div>

        <hr style="border-color: #555;">

        <div class="control-group">
            <label>Terreno (m) <span id="v-terrain">300</span></label>
            <input type="range" id="sl-terrain" min="200" max="2000" step="100" value="300">
        </div>
        <div class="control-group">
            <label>Postes <span id="v-posts">20</span></label>
            <input type="range" id="sl-posts" min="3" max="50" step="1" value="20">
        </div>
        <div class="control-group">
            <label>Rivales <span id="v-balls">5</span></label>
            <input type="range" id="sl-balls" min="0" max="20" step="1" value="5">
        </div>
        <div class="control-group">
            <label>Distancia Punto Previo (m) <span id="v-preRingDistance">1</span></label>
            <input type="range" id="sl-preRingDistance" min="1" max="20" step="1" value="15">
        </div>
        <div class="control-group">
            <label>Altura Máxima Postes (m) <span id="v-maxPostHeight">10</span></label>
            <input type="range" id="sl-maxPostHeight" min="1" max="25" step="0.5" value="10">
        </div>
        <div class="control-group">
            <label>Suavidad de Curvas (0=redondeado, 1=recto) <span id="v-splineTension">0.1</span></label>
            <input type="range" id="sl-splineTension" min="0" max="1" step="0.05" value="0.1">
        </div>
    </div>

    <div id="status">
        <div id="status-pill">CARGANDO...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- REFERENCIAS UI ---
        const statusEl = document.getElementById('status-pill');
        const updateStatus = (msg, color = '#ffff00') => {
            statusEl.innerText = msg;
            statusEl.style.color = color;
            statusEl.style.borderColor = color;
            console.log(`[STATUS] ${msg}`);
        };

        // --- VARIABLES GLOBALES ---
        const CONFIG = {
            speed: 0.25,
            fog: 300,
            height: 25,
            terrainSize: 300,
            numPosts: 20,
            numBalls: 5,
            preRingDistance: 15,
            maxPostHeight: 10,
            maxPostHeight: 10,
            splineTension: 0.1,
            isNight: false
        };

        // --- VARIABLES FPS ---
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        // --- ESCENA THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, CONFIG.fog);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- FUNCIÓN PARA CARGAR SKYBOX ---
        function setupSkybox(url) {
            const loader = new THREE.ImageLoader();
            loader.setCrossOrigin('anonymous');

            updateStatus("CARGANDO SKYBOX...", "#ffff00");

            loader.load(url, (image) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                const tileWidth = image.width / 4;
                const tileHeight = image.height / 3;
                canvas.width = tileWidth;
                canvas.height = tileHeight;

                const getTile = (x, y) => {
                    ctx.drawImage(image, x * tileWidth, y * tileHeight, tileWidth, tileHeight, 0, 0, tileWidth, tileHeight);
                    const c = document.createElement('canvas');
                    c.width = tileWidth;
                    c.height = tileHeight;
                    c.getContext('2d').drawImage(canvas, 0, 0);
                    return c;
                };

                const faces = [
                    getTile(2, 1), // px
                    getTile(0, 1), // nx
                    getTile(1, 0), // py
                    getTile(1, 2), // ny
                    getTile(1, 1), // pz
                    getTile(3, 1)  // nz
                ];

                const cubeTexture = new THREE.CubeTexture(faces);
                cubeTexture.needsUpdate = true;
                scene.background = cubeTexture;
                updateStatus("SKYBOX OK", "#00ff00");

                // Pequeño timeout para limpiar mensaje
                setTimeout(() => updateStatus("LISTO", "#00ff00"), 2000);

            }, undefined, (err) => {
                console.warn("Error cargando skybox", err);
                updateStatus("ERROR SKYBOX", "#ff0000");
            });
        }

        setupSkybox('./skybox.jpeg');

        // --- SISTEMA DE TEMAS ---
        function updateTheme() {
            if (CONFIG.isNight) {
                // MODO NOCHE: Cyberpunk Neon
                setupSkybox('./nightskybox.jpg');

                // Luces: Oscuridad general, solo glow
                scene.fog.color.setHex(0x000510);
                scene.fog.near = 10;
                scene.fog.far = CONFIG.fog;

                ambientLight.intensity = 0.1;
                dirLight.intensity = 0.0; // Desactivar luz direccional principal para que resalte el neón

                // Terreno oscuro
                if (terrainMesh) {
                    terrainMesh.visible = !CONFIG.isNight; // Hide solid floor in night
                    if (!CONFIG.isNight) {
                        terrainMesh.material.color.setHex(0x55aa55);
                        terrainMesh.material.emissive.setHex(0x000000);
                    }
                }

                if (gridHelper) {
                    gridHelper.visible = CONFIG.isNight; // Show grid in night
                }

                // Postes (Pillars) - Hacerlos oscuros con glow suave
                postMat.color.setHex(0x111111);
                postMat.emissive.setHex(0x4400cc); // Violeta/Azul oscuro
                postMat.emissiveIntensity = 0.8;

                // Actualizar objetos dinámicos (Aros)
                postsData.forEach(p => {
                    // Mantener el color base del estado del juego (rojo, amarillo, azul)
                    // Pero hacerlo brillar intensamente
                    const color = p.mesh.material.color;
                    p.mesh.material.emissive.copy(color);
                    p.mesh.material.emissiveIntensity = 2.0;
                });

                // Actualizar Balones Rivales
                ballsArray.forEach(b => {
                    const color = b.mesh.material.color;
                    b.mesh.material.emissive.copy(color);
                    b.mesh.material.emissiveIntensity = 2.0;
                });

            } else {
                // MODO DÍA: Normal
                setupSkybox('./skybox.jpeg');

                scene.fog.color.setHex(0x87CEEB);
                scene.fog.near = 20;

                ambientLight.intensity = 0.6;
                dirLight.intensity = 0.8;

                if (terrainMesh) {
                    terrainMesh.visible = !CONFIG.isNight;
                    if (!CONFIG.isNight) {
                        terrainMesh.material.color.setHex(0x55aa55);
                        terrainMesh.material.emissive.setHex(0x000000);
                    }
                }

                if (gridHelper) {
                    gridHelper.visible = CONFIG.isNight;
                }

                // Postes (Pillars)
                postMat.color.setHex(0x888888);
                postMat.emissive.setHex(0x000000);

                // Aros
                postsData.forEach(p => {
                    // Restaurar emissive standard
                    // El juego usa emissive para highlighting, así que debemos tener cuidado.
                    // En modo día el juego espera controlar el emissive. 
                    // Restauraremos a un estado base, pero la lógica del juego sobreescribirá cuando sea necesario.
                    // Por ahora reseteamos a negro o al color de estado si está activo?
                    // Mejor: reseteamos emissive a negro y dejamos que el juego maneje el brillo de los activos (startPlayerRound/animate lo hacen)
                    p.mesh.material.emissiveIntensity = 1.0;
                    // NOTA: animate() setea emissive para activo/pasado. 
                    // Lo resetearemos a negro aqui, y el juego lo volverá a pintar si es necesario en el siguiente frame.
                    // Ojo: los aros inactivos tienen amarillo y emissive negro.
                    // El loop del juego setea:
                    // Activo: color 0088ff, emissive 004488
                    // Pasado: color ff0000, emissive 550000
                    // Inactivo: color ffaa00, emissive 000000

                    // Si solo bajamos la intensidad o reseteamos a negro?
                    // Vamos a confiar en que el render loop o lógica de juego repinta lo necesario.
                    // Pero para los inactivos (la mayoría), emissive debe ser negro.
                    p.mesh.material.emissive.setHex(0x000000);

                    // Re-aplicar estado actual si es el target
                    // (Es complejo saber cuál es el target desde aquí sin iterar indices, pero el animate loop corre constante)
                });

                ballsArray.forEach(b => {
                    b.mesh.material.emissive.setHex(0x000000);
                });
            }
        }

        // Luces
        // Luces
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -1000;
        dirLight.shadow.camera.right = 1000;
        dirLight.shadow.camera.top = 1000;
        dirLight.shadow.camera.bottom = -1000;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Grupos y Datos
        let postsGroup = new THREE.Group();
        scene.add(postsGroup);

        let terrainMesh = null;
        let gridHelper = null;
        let postsData = [];
        let ballsArray = [];
        let postMat = new THREE.MeshStandardMaterial({ color: 0x888888 });

        // Variables de Vuelo Jugador
        let playerCurve = null;
        let playerProgress = 0;
        let playerPathIndices = [];
        let playerCurrentTargetIdx = 0;
        let playerNextStartId = 0;

        // --- FUNCIONES AUXILIARES ---
        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // Función para detectar si un punto está cerca de un segmento de línea
        function pointToSegmentDistance(point, lineStart, lineEnd) {
            const lineVec = lineEnd.clone().sub(lineStart);
            const pointVec = point.clone().sub(lineStart);
            const lineLength = lineVec.length();

            if (lineLength === 0) return pointVec.length();

            // Proyección del punto sobre la línea
            const t = Math.max(0, Math.min(1, pointVec.dot(lineVec) / (lineLength * lineLength)));
            const projection = lineStart.clone().add(lineVec.multiplyScalar(t));

            return point.distanceTo(projection);
        }

        // Función para detectar postes cercanos al camino entre dos puntos
        function findNearbyPostsOnPath(startPoint, endPoint, threshold = 3.0) {
            const nearbyPosts = [];

            for (let post of postsData) {
                const distance = pointToSegmentDistance(post.center, startPoint, endPoint);
                if (distance < threshold && distance > 0.1) { // Excluir postes de inicio/fin
                    nearbyPosts.push({
                        post: post,
                        distance: distance,
                        closestPoint: post.center.clone()
                    });
                }
            }

            return nearbyPosts.sort((a, b) => a.distance - b.distance);
        }

        // Crear curva de vuelo simplificada con splines
        function createSimpleSplinePath(startId, targetIds) {
            if (!postsData[startId]) return null;

            const points = [];
            const startPost = postsData[startId];

            // Punto inicial - posición elevada cerca del poste de inicio
            const startPoint = startPost.center.clone();
            startPoint.y = CONFIG.height; // Usar directamente la altura configurada
            points.push(startPoint);

            for (let id of targetIds) {
                const post = postsData[id];
                if (!post) continue;

                // Obtener el último punto agregado
                const lastPoint = points[points.length - 1];

                // Crear punto de descenso a la mitad de camino al aro
                const approachMidPoint = new THREE.Vector3(
                    (lastPoint.x + post.center.x) / 2,
                    (lastPoint.y + post.center.y) / 2,
                    (lastPoint.z + post.center.z) / 2
                );
                points.push(approachMidPoint);

                // Detectar postes cercanos al camino entre el último punto y este poste
                const nearbyPosts = findNearbyPostsOnPath(lastPoint, post.center, 4.0); // Umbral de 4 metros

                // Agregar puntos de desvío para postes en el camino
                for (let nearby of nearbyPosts) {
                    // Si el poste cercano no es el destino actual ni el de origen
                    if (nearby.post.id !== id && nearby.post.id !== startId) {
                        console.log(`[EVASIÓN] Poste ${nearby.post.id} detectado a ${nearby.distance.toFixed(1)}m del camino. Agregando punto de desvío.`);
                        // Crear punto de desvío 2 metros por encima del poste
                        const avoidancePoint = nearby.post.center.clone();
                        avoidancePoint.y += Math.max(2, nearby.post.center.y + 2); // Asegurar que el punto de desvío esté por encima del poste
                        points.push(avoidancePoint);
                    }
                }

                // Usar el vector normal del aro para la dirección
                const direction = post.normal.clone();

                // Punto ANTES del aro (approach) - a la misma altura del aro
                const beforePoint = post.center.clone()
                    .add(direction.clone().multiplyScalar(-CONFIG.preRingDistance)); // Usar valor del slider
                // Mantener la altura del aro para alinearse correctamente
                beforePoint.y = post.center.y;
                points.push(beforePoint);

                // Punto en el CENTRO del aro - mantener altura del aro para pasar correctamente
                points.push(post.center.clone());

                // Punto DESPUÉS del aro (exit) - a la misma altura del aro
                const afterPoint = post.center.clone()
                    .add(direction.clone().multiplyScalar(CONFIG.preRingDistance)); // Usar valor del slider
                // Mantener la altura del aro para una transición suave
                afterPoint.y = post.center.y;
                points.push(afterPoint);

                // Crear punto de ascenso a la altura de vuelo para el siguiente segmento
                const exitTransitionPoint = afterPoint.clone();
                exitTransitionPoint.y = CONFIG.height;
                points.push(exitTransitionPoint);
            }

            if (points.length < 2) return null;

            // Crear spline suave con Catmull-Rom
            const curve = new THREE.CatmullRomCurve3(points);
            curve.tension = CONFIG.splineTension; // Usar la tensión configurada
            return curve;
        }

        // Crear curva de vuelo (mantener función original para compatibilidad)
        function createCurve(startId, targetIds) {
            return createSimpleSplinePath(startId, targetIds);
        }

        // --- CLASE DRONE RIVAL MEJORADA ---
        class DroneBall {
            constructor(color, startId) {
                const geo = new THREE.SphereGeometry(0.8, 16, 16);
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.castShadow = true;
                postsGroup.add(this.mesh);

                this.currentStartId = startId;
                this.curve = null;
                this.progress = 0;
                this.speed = CONFIG.speed * (0.8 + Math.random() * 0.4); // Velocidad variable para cada bola
                this.nextStartId = 0;

                this.planNewRoute();
            }

            planNewRoute() {
                if (postsData.length < 2) return;

                const available = postsData.map(p => p.id).filter(id => id !== this.currentStartId);
                const routeIds = shuffle(available);

                this.nextStartId = routeIds[routeIds.length - 1];
                this.curve = createSimpleSplinePath(this.currentStartId, routeIds);
                this.progress = 0;
            }

            update() {
                if (!this.curve) return;

                const len = this.curve.getLength();
                if (len < 1) return;

                // Paso basado en la velocidad individual de la bola
                const step = this.speed / len;
                this.progress += step;

                if (this.progress >= 1) {
                    this.currentStartId = this.nextStartId;
                    this.planNewRoute();
                } else {
                    this.mesh.position.copy(this.curve.getPointAt(this.progress));
                }
            }
        }

        // --- SISTEMA PRINCIPAL ---

        function startPlayerRound(startId) {
            // Limpiar colores
            postsData.forEach(p => {
                p.mesh.material.color.setHex(0xffaa00); // Amarillo
                p.mesh.material.emissive.setHex(0x000000);
            });

            const available = postsData.map(p => p.id).filter(id => id !== startId);
            playerPathIndices = shuffle(available);

            if (playerPathIndices.length === 0) {
                updateStatus("ERROR: NO HAY SUFICIENTES POSTES", "#ff0000");
                return;
            }

            // Marcar primer objetivo
            playerCurrentTargetIdx = 0;
            const firstId = playerPathIndices[0];
            postsData[firstId].mesh.material.color.setHex(0x0088ff); // Azul
            postsData[firstId].mesh.material.emissive.setHex(0x004488);

            // Generar curva
            playerNextStartId = playerPathIndices[playerPathIndices.length - 1];
            playerCurve = createCurve(startId, playerPathIndices);
            playerProgress = 0;

            updateStatus(`OBJETIVOS: ${playerPathIndices.length}`, "#44aaff");
        }

        function generateWorld() {
            updateStatus("GENERANDO MUNDO...", "#ffff00");

            if (terrainMesh) {
                scene.remove(terrainMesh);
                terrainMesh.geometry.dispose();
            }
            while (postsGroup.children.length > 0) {
                postsGroup.remove(postsGroup.children[0]);
            }
            postsData = [];
            ballsArray = [];

            // Terreno
            const planeGeo = new THREE.PlaneGeometry(CONFIG.terrainSize, CONFIG.terrainSize);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x55aa55, roughness: 0.8 });
            terrainMesh = new THREE.Mesh(planeGeo, planeMat);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.receiveShadow = true;
            terrainMesh.receiveShadow = true;
            terrainMesh.visible = !CONFIG.isNight; // Initial visibility
            scene.add(terrainMesh);

            // Grid para Night Mode
            if (gridHelper) {
                scene.remove(gridHelper);
                gridHelper.geometry.dispose();
            }
            // GridHelper( size, divisions, colorCenterLine, colorGrid )
            gridHelper = new THREE.GridHelper(CONFIG.terrainSize, CONFIG.terrainSize / 10, 0x00ff00, 0x004400);
            gridHelper.position.y = 0.1;
            gridHelper.visible = CONFIG.isNight;
            scene.add(gridHelper);

            // Re-aplicar tema al generar nuevo mundo si estamos en modo noche
            if (CONFIG.isNight) {
                // No necesitamos cambiar material del terreno porque está invisible
                // Pero si quisieramos mantener propiedaes correctas por si acaso:
                terrainMesh.material.color.setHex(0x000000);
            }

            // Postes
            const postGeo = new THREE.CylinderGeometry(0.2, 0.2, 10, 8);
            const ringGeo = new THREE.TorusGeometry(1.5, 0.15, 8, 24);
            // postMat is now global

            // Re-aplicar tema al material de los postes
            if (CONFIG.isNight) {
                postMat.color.setHex(0x111111);
                postMat.emissive.setHex(0x4400cc);
                postMat.emissiveIntensity = 0.8;
            }

            const ringMatBase = new THREE.MeshStandardMaterial({ color: 0xffaa00 });

            // Algoritmo de distribución con distancia mínima
            const minDistance = 10; // Distancia mínima entre postes en metros
            const maxRadius = CONFIG.terrainSize * 0.45; // 45% del tamaño del terreno para evitar bordes
            const postPositions = [];

            for (let i = 0; i < CONFIG.numPosts; i++) {
                let x, z;
                let attempts = 0;
                const maxAttempts = 100;

                // Intentar encontrar una posición válida
                do {
                    const radius = Math.random() * maxRadius;
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                    attempts++;
                } while (attempts < maxAttempts && postPositions.some(pos => {
                    const distance = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    return distance < minDistance;
                }));

                // Si no se encontró una posición válida, usar la última generada
                postPositions.push({ x, z });
                const h = 1 + Math.random() * (CONFIG.maxPostHeight - 1); // Altura aleatoria entre 1 y maxPostHeight metros

                const post = new THREE.Mesh(postGeo, postMat);
                post.scale.y = h / 10;
                post.position.set(x, h / 2, z);
                post.castShadow = true;
                postsGroup.add(post);

                const ring = new THREE.Mesh(ringGeo, ringMatBase.clone());
                const ringY = h + 1.5 + 0.15;
                ring.position.set(x, ringY, z);
                ring.rotation.y = Math.random() * Math.PI * 2;
                postsGroup.add(ring);

                // Calcular vector normal que apunta en la dirección "hacia adelante" del aro
                // El aro está en el plano XY, así que rotamos un vector en el plano XZ
                const angle = ring.rotation.y;
                const normal = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle)).normalize();

                const center = new THREE.Vector3(x, ringY, z);

                postsData.push({
                    id: i,
                    center: center,
                    normal: normal,
                    entry: center.clone().add(normal.clone().multiplyScalar(4)),
                    exit: center.clone().sub(normal.clone().multiplyScalar(4)),
                    mesh: ring
                });
            }

            if (postsData.length > 1) {
                const startNode = postsData[0];
                const startPos = startNode.center.clone().sub(startNode.normal.clone().multiplyScalar(15));
                startPos.y = CONFIG.height; // Usar la altura de vuelo configurada, no la altura del aro
                camera.position.copy(startPos);
                camera.lookAt(startNode.center);

                startPlayerRound(0);
            }

            for (let i = 0; i < CONFIG.numBalls; i++) {
                const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
                const startId = (i + 1) % CONFIG.numPosts;
                ballsArray.push(new DroneBall(color, startId));
            }
        }

        // --- FUNCIÓN PARA CALCULAR FPS ---
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;

            // Actualizar FPS cada segundo
            if (deltaTime >= 1000) {
                fps = Math.round((frameCount * 1000) / deltaTime);
                document.getElementById('fps-value').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // --- LOOP DE ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);

            if (playerCurve) {
                const len = playerCurve.getLength();
                if (len > 1) {
                    const step = CONFIG.speed / len;
                    playerProgress += step;

                    if (playerProgress >= 1) {
                        startPlayerRound(playerNextStartId);
                    } else {
                        // Movimiento
                        const pos = playerCurve.getPointAt(playerProgress);
                        camera.position.copy(pos);

                        // Mirar siempre al próximo aro objetivo
                        if (playerCurrentTargetIdx < playerPathIndices.length) {
                            const targetId = playerPathIndices[playerCurrentTargetIdx];
                            const target = postsData[targetId];
                            camera.lookAt(target.center);
                        } else {
                            // Si no hay más objetivos, mirar hacia adelante en la curva
                            const lookAheadDistance = 3.0;
                            const lookAtT = Math.min(playerProgress + (lookAheadDistance / len), 1);
                            const lookAtPos = playerCurve.getPointAt(lookAtT);
                            camera.lookAt(lookAtPos);
                        }

                        if (playerCurrentTargetIdx < playerPathIndices.length) {
                            const targetId = playerPathIndices[playerCurrentTargetIdx];
                            const target = postsData[targetId];

                            // Detectar cuando la cámara pasa por el aro
                            const distanceToCenter = camera.position.distanceTo(target.center);

                            // Si la cámara está muy cerca del centro del aro (menos de 1.5 metros)
                            if (distanceToCenter < 1.5) {
                                // Marcar aro actual como pasado (rojo)
                                target.mesh.material.color.setHex(0xff0000);
                                target.mesh.material.emissive.setHex(0x550000);

                                // Avanzar al siguiente aro
                                playerCurrentTargetIdx++;
                                const left = playerPathIndices.length - playerCurrentTargetIdx;
                                updateStatus(`PENDIENTES: ${left}`, "#44aaff");

                                // Marcar el siguiente aro como objetivo (azul)
                                if (playerCurrentTargetIdx < playerPathIndices.length) {
                                    const nextId = playerPathIndices[playerCurrentTargetIdx];
                                    postsData[nextId].mesh.material.color.setHex(0x0088ff);
                                    postsData[nextId].mesh.material.emissive.setHex(0x004488);
                                } else {
                                    // Todos los aros pasados
                                    updateStatus("¡VUELTA TERMINADA!", "#00ff00");
                                }
                            }
                        }
                    }
                }
            }

            ballsArray.forEach(b => {
                b.update();
                // En modo noche, asegurar que el brillo sigue el color
                if (CONFIG.isNight) {
                    b.mesh.material.emissive.copy(b.mesh.material.color);
                }
            });

            // Actualizar contador de FPS
            updateFPS();

            renderer.render(scene, camera);
        }

        // --- EVENTOS UI ---
        document.getElementById('sl-speed').oninput = (e) => {
            CONFIG.speed = parseFloat(e.target.value);
            document.getElementById('v-speed').innerText = CONFIG.speed;
        };
        document.getElementById('sl-fog').oninput = (e) => {
            CONFIG.fog = parseFloat(e.target.value);
            scene.fog.far = CONFIG.fog;
            document.getElementById('v-fog').innerText = CONFIG.fog;
        };
        document.getElementById('sl-height').oninput = (e) => {
            CONFIG.height = parseFloat(e.target.value);
            document.getElementById('v-height').innerText = CONFIG.height;
        };

        let timer;
        const triggerReload = () => {
            clearTimeout(timer);
            timer = setTimeout(generateWorld, 500);
        };

        document.getElementById('sl-terrain').oninput = (e) => {
            CONFIG.terrainSize = parseInt(e.target.value);
            document.getElementById('v-terrain').innerText = CONFIG.terrainSize;
            triggerReload();
        };
        document.getElementById('sl-posts').oninput = (e) => {
            CONFIG.numPosts = parseInt(e.target.value);
            document.getElementById('v-posts').innerText = CONFIG.numPosts;
            triggerReload();
        };
        document.getElementById('sl-balls').oninput = (e) => {
            CONFIG.numBalls = parseInt(e.target.value);
            document.getElementById('v-balls').innerText = CONFIG.numBalls;
            triggerReload();
        };
        document.getElementById('sl-preRingDistance').oninput = (e) => {
            CONFIG.preRingDistance = parseInt(e.target.value);
            document.getElementById('v-preRingDistance').innerText = CONFIG.preRingDistance;
        };
        document.getElementById('sl-maxPostHeight').oninput = (e) => {
            CONFIG.maxPostHeight = parseFloat(e.target.value);
            document.getElementById('v-maxPostHeight').innerText = CONFIG.maxPostHeight;
            triggerReload(); // Resetea el sistema cuando cambia la altura máxima
        };
        document.getElementById('sl-splineTension').oninput = (e) => {
            CONFIG.splineTension = parseFloat(e.target.value);
            document.getElementById('v-splineTension').innerText = CONFIG.splineTension;
            triggerReload(); // Resetea el sistema cuando cambia la suavidad de curvas
        };

        // Evento Modo Nocturno
        document.getElementById('chk-theme').onchange = (e) => {
            CONFIG.isNight = e.target.checked;
            updateTheme();
        };

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };

        generateWorld();

        // Inicializar valores de display
        document.getElementById('v-preRingDistance').innerText = CONFIG.preRingDistance;
        document.getElementById('v-maxPostHeight').innerText = CONFIG.maxPostHeight;

        animate();

    </script>
</body>

</html>