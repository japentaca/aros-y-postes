<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cabeza de pelota de Pato</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', sans-serif;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            background: rgba(0, 20, 40, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            z-index: 20;
            max-height: 90vh;
            overflow-y: auto;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        #controls.collapsed {
            max-height: 50px;
            overflow: hidden;
            padding-bottom: 15px;
        }

        #toggle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
            user-select: none;
        }

        #toggle-header h3 {
            margin: 0;
            color: #44aaff;
            border-bottom: 1px solid #44aaff;
            flex-grow: 1;
            padding-bottom: 5px;
        }

        #toggle-btn {
            background: none;
            border: none;
            color: #44aaff;
            font-size: 1.2em;
            cursor: pointer;
            transition: transform 0.3s ease;
            padding: 0 0 5px 10px;
            line-height: 1;
            margin-left: 10px;
        }

        #controls.collapsed #toggle-btn {
            transform: rotate(-90deg);
        }

        .controls-content {
            transition: opacity 0.3s ease;
        }

        #controls.collapsed .controls-content {
            opacity: 0;
            pointer-events: none;
        }

        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 20;
            border: 1px solid #00ff00;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #44aaff;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #44aaff;
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        #status {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #status-pill {
            display: inline-block;
            background: rgba(0, 0, 0, 0.8);
            color: #ffff00;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: monospace;
            font-size: 1.2em;
            border: 2px solid #ffff00;
        }
    </style>
</head>

<body>

    <div id="fps-counter">FPS: <span id="fps-value">0</span></div>

    <div id="controls">
        <div id="toggle-header">
            <h3>CONFIGURACIÓN</h3>
            <button id="toggle-btn" title="Colapsar/Expandir">▼</button>
        </div>
        <div class="controls-content">

            <div class="control-group">
                <label>
                    Modo Nocturno (Neon)
                    <label class="switch">
                        <input type="checkbox" id="chk-theme">
                        <span class="slider"></span>
                    </label>
                </label>
            </div>
            <!-- Checkbox de Mostrar Spline - Comentado visualmente pero funcional -->
            <div class="control-group" style="display: none;">
                <label>
                    Mostrar Spline Cámara
                    <label class="switch">
                        <input type="checkbox" id="chk-spline">
                        <span class="slider"></span>
                    </label>
                </label>
            </div>
            <div class="control-group">
                <label>Velocidad <span id="v-speed">0.25</span></label>
                <input type="range" id="sl-speed" min="0.05" max="1.5" step="0.05" value="0.25">
            </div>

            <div class="control-group">
                <label>Altura Vuelo <span id="v-height">25</span></label>
                <input type="range" id="sl-height" min="10" max="100" step="5" value="25">
            </div>

            <hr style="border-color: #555;">

            <div class="control-group">
                <label>Terreno (m) <span id="v-terrain">300</span></label>
                <input type="range" id="sl-terrain" min="200" max="2000" step="100" value="300">
            </div>
            <div class="control-group">
                <label>Postes <span id="v-posts">20</span></label>
                <input type="range" id="sl-posts" min="3" max="50" step="1" value="20">
            </div>
            <div class="control-group">
                <label>Rivales <span id="v-balls">5</span></label>
                <input type="range" id="sl-balls" min="0" max="20" step="1" value="5">
            </div>
            <div class="control-group">
                <label>Distancia Punto Previo (m) <span id="v-preRingDistance">1</span></label>
                <input type="range" id="sl-preRingDistance" min="1" max="20" step="1" value="15">
            </div>
            <div class="control-group">
                <label>Altura Máxima Postes (m) <span id="v-maxPostHeight">10</span></label>
                <input type="range" id="sl-maxPostHeight" min="1" max="25" step="0.5" value="10">
            </div>
        </div>
    </div>

    <div id="status">
        <div id="status-pill">CARGANDO...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- REFERENCIAS UI ---
        // Toggle Panel Colapsable
        const toggleBtn = document.getElementById('toggle-btn');
        const toggleHeader = document.getElementById('toggle-header');
        const controlsPanel = document.getElementById('controls');

        toggleHeader.addEventListener('click', () => {
            controlsPanel.classList.toggle('collapsed');
        });

        const statusEl = document.getElementById('status-pill');
        const updateStatus = (msg, color = '#ffff00') => {
            statusEl.innerText = msg;
            statusEl.style.color = color;
            statusEl.style.borderColor = color;
            statusEl.style.borderColor = color;
        };

        // --- VARIABLES GLOBALES ---
        const CONFIG = {
            speed: 0.25,
            height: 25,
            terrainSize: 300,
            numPosts: 20,
            numBalls: 5,
            preRingDistance: 15,
            maxPostHeight: 10,
            maxPostHeight: 10,
            splineTension: 0,
            isNight: false,
            showSpline: false
        };

        // --- VARIABLES FPS ---
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;
        let lastFrameTime = performance.now();

        // --- ESCENA THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- FUNCIÓN PARA CARGAR SKYBOX ---
        function setupSkybox(url) {
            const loader = new THREE.ImageLoader();
            loader.setCrossOrigin('anonymous');

            updateStatus("CARGANDO SKYBOX...", "#ffff00");

            loader.load(url, (image) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                const tileWidth = image.width / 4;
                const tileHeight = image.height / 3;
                canvas.width = tileWidth;
                canvas.height = tileHeight;

                const getTile = (x, y) => {
                    ctx.drawImage(image, x * tileWidth, y * tileHeight, tileWidth, tileHeight, 0, 0, tileWidth, tileHeight);
                    const c = document.createElement('canvas');
                    c.width = tileWidth;
                    c.height = tileHeight;
                    c.getContext('2d').drawImage(canvas, 0, 0);
                    return c;
                };

                const faces = [
                    getTile(2, 1), // px
                    getTile(0, 1), // nx
                    getTile(1, 0), // py
                    getTile(1, 2), // ny
                    getTile(1, 1), // pz
                    getTile(3, 1)  // nz
                ];

                const cubeTexture = new THREE.CubeTexture(faces);
                cubeTexture.needsUpdate = true;
                scene.background = cubeTexture;
                updateStatus("SKYBOX OK", "#00ff00");

                // Pequeño timeout para limpiar mensaje
                setTimeout(() => updateStatus("LISTO", "#00ff00"), 2000);

            }, undefined, (err) => {
                console.warn("Error cargando skybox", err);
                updateStatus("ERROR SKYBOX", "#ff0000");
            });
        }

        setupSkybox('./skybox.jpeg');

        // --- SISTEMA DE TEMAS ---
        function updateTheme() {
            if (CONFIG.isNight) {
                // MODO NOCHE: Cyberpunk Neon
                setupSkybox('./nightskybox.jpg');

                // Luces: Oscuridad general, solo glow

                ambientLight.intensity = 0.1;
                dirLight.intensity = 0.0; // Desactivar luz direccional principal para que resalte el neón

                // Terreno oscuro
                if (terrainMesh) {
                    terrainMesh.visible = !CONFIG.isNight; // Hide solid floor in night
                    if (!CONFIG.isNight) {
                        terrainMesh.material.color.setHex(0x55aa55);
                        terrainMesh.material.emissive.setHex(0x000000);
                    }
                }

                if (gridHelper) {
                    gridHelper.visible = CONFIG.isNight; // Show grid in night
                }

                // Postes (Pillars) - Hacerlos oscuros con glow suave
                postMat.color.setHex(0x111111);
                postMat.emissive.setHex(0x4400cc); // Violeta/Azul oscuro
                postMat.emissiveIntensity = 0.8;

                // Actualizar objetos dinámicos (Aros)
                postsData.forEach(p => {
                    // Mantener el color base del estado del juego (rojo, amarillo, azul)
                    // Pero hacerlo brillar intensamente
                    const color = p.mesh.material.color;
                    p.mesh.material.emissive.copy(color);
                    p.mesh.material.emissiveIntensity = 2.0;
                });

                // Actualizar Balones Rivales
                ballsArray.forEach(b => {
                    const color = b.mesh.material.color;
                    b.mesh.material.emissive.copy(color);
                    b.mesh.material.emissiveIntensity = 2.0;
                });

            } else {
                // MODO DÍA: Normal
                setupSkybox('./skybox.jpeg');

                ambientLight.intensity = 0.6;
                dirLight.intensity = 0.8;

                if (terrainMesh) {
                    terrainMesh.visible = !CONFIG.isNight;
                    if (!CONFIG.isNight) {
                        terrainMesh.material.color.setHex(0x55aa55);
                        terrainMesh.material.emissive.setHex(0x000000);
                    }
                }

                if (gridHelper) {
                    gridHelper.visible = CONFIG.isNight;
                }

                // Postes (Pillars)
                postMat.color.setHex(0x888888);
                postMat.emissive.setHex(0x000000);

                // Aros
                postsData.forEach(p => {
                    // Restaurar emissive standard
                    // El juego usa emissive para highlighting, así que debemos tener cuidado.
                    // En modo día el juego espera controlar el emissive. 
                    // Restauraremos a un estado base, pero la lógica del juego sobreescribirá cuando sea necesario.
                    // Por ahora reseteamos a negro o al color de estado si está activo?
                    // Mejor: reseteamos emissive a negro y dejamos que el juego maneje el brillo de los activos (startPlayerRound/animate lo hacen)
                    p.mesh.material.emissiveIntensity = 1.0;
                    // NOTA: animate() setea emissive para activo/pasado. 
                    // Lo resetearemos a negro aqui, y el juego lo volverá a pintar si es necesario en el siguiente frame.
                    // Ojo: los aros inactivos tienen amarillo y emissive negro.
                    // El loop del juego setea:
                    // Activo: color 0088ff, emissive 004488
                    // Pasado: color ff0000, emissive 550000
                    // Inactivo: color ffaa00, emissive 000000

                    // Si solo bajamos la intensidad o reseteamos a negro?
                    // Vamos a confiar en que el render loop o lógica de juego repinta lo necesario.
                    // Pero para los inactivos (la mayoría), emissive debe ser negro.
                    p.mesh.material.emissive.setHex(0x000000);

                    // Re-aplicar estado actual si es el target
                    // (Es complejo saber cuál es el target desde aquí sin iterar indices, pero el animate loop corre constante)
                });

                ballsArray.forEach(b => {
                    b.mesh.material.emissive.setHex(0x000000);
                });
            }
        }

        // Luces
        // Luces
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -1000;
        dirLight.shadow.camera.right = 1000;
        dirLight.shadow.camera.top = 1000;
        dirLight.shadow.camera.bottom = -1000;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Grupos y Datos
        let postsGroup = new THREE.Group();
        scene.add(postsGroup);

        let terrainMesh = null;
        let gridHelper = null;
        let postsData = [];
        let ballsArray = [];
        let postMat = new THREE.MeshStandardMaterial({ color: 0x888888 });

        // Variables de Vuelo Jugador
        let playerCurve = null;
        let playerProgress = 0;
        let playerPathIndices = [];
        let playerCurrentTargetIdx = 0;
        let playerNextStartId = 0;

        // Helper visual de la spline
        let splineHelper = null;
        let splinePoints = null;

        // Sistema de transición suave del lookAt
        let lookAtTransition = {
            active: false,
            startTime: 0,
            duration: 3000, // 3 segundos
            startTarget: new THREE.Vector3(),
            endTarget: new THREE.Vector3()
        };

        // --- FUNCIONES AUXILIARES ---
        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // Función para detectar si un punto está cerca de un segmento de línea
        function pointToSegmentDistance(point, lineStart, lineEnd) {
            const lineVec = lineEnd.clone().sub(lineStart);
            const pointVec = point.clone().sub(lineStart);
            const lineLength = lineVec.length();

            if (lineLength === 0) return pointVec.length();

            // Proyección del punto sobre la línea
            const t = Math.max(0, Math.min(1, pointVec.dot(lineVec) / (lineLength * lineLength)));
            const projection = lineStart.clone().add(lineVec.multiplyScalar(t));

            return point.distanceTo(projection);
        }

        // Función para detectar postes cercanos al camino entre dos puntos
        function findNearbyPostsOnPath(startPoint, endPoint, threshold = 3.0) {
            const nearbyPosts = [];

            for (let post of postsData) {
                const distance = pointToSegmentDistance(post.center, startPoint, endPoint);
                if (distance < threshold && distance > 0.1) { // Excluir postes de inicio/fin
                    nearbyPosts.push({
                        post: post,
                        distance: distance,
                        closestPoint: post.center.clone()
                    });
                }
            }

            return nearbyPosts.sort((a, b) => a.distance - b.distance);
        }

        // Crear curva de vuelo simplificada con splines
        function createSimpleSplinePath(startId, targetIds) {
            if (!postsData[startId]) return null;

            const points = [];
            const startPost = postsData[startId];

            // Punto inicial - posición elevada cerca del poste de inicio
            const startPoint = startPost.center.clone();
            startPoint.y = CONFIG.height; // Usar directamente la altura configurada
            points.push(startPoint);

            for (let id of targetIds) {
                const post = postsData[id];
                if (!post) continue;

                // Obtener el último punto agregado
                const lastPoint = points[points.length - 1];

                // Crear punto de descenso a la mitad de camino al aro
                const approachMidPoint = new THREE.Vector3(
                    (lastPoint.x + post.center.x) / 2,
                    (lastPoint.y + post.center.y) / 2,
                    (lastPoint.z + post.center.z) / 2
                );
                points.push(approachMidPoint);

                // Detectar postes cercanos al camino entre el último punto y este poste
                const nearbyPosts = findNearbyPostsOnPath(lastPoint, post.center, 4.0); // Umbral de 4 metros

                // Agregar puntos de desvío para postes en el camino
                for (let nearby of nearbyPosts) {
                    // Si el poste cercano no es el destino actual ni el de origen
                    if (nearby.post.id !== id && nearby.post.id !== startId) {

                        // Crear punto de desvío 2 metros por encima del poste
                        const avoidancePoint = nearby.post.center.clone();
                        avoidancePoint.y += Math.max(2, nearby.post.center.y + 2); // Asegurar que el punto de desvío esté por encima del poste
                        points.push(avoidancePoint);
                    }
                }

                // Usar el vector normal del aro para la dirección
                const direction = post.normal.clone();

                // Punto ANTES del aro (approach) - a la misma altura del aro
                const beforePoint = post.center.clone()
                    .add(direction.clone().multiplyScalar(-CONFIG.preRingDistance)); // Usar valor del slider
                // Mantener la altura del aro para alinearse correctamente
                beforePoint.y = post.center.y;
                points.push(beforePoint);

                // Punto en el CENTRO del aro - mantener altura del aro para pasar correctamente
                points.push(post.center.clone());

                // Punto DESPUÉS del aro (exit) - a la misma altura del aro
                const afterPoint = post.center.clone()
                    .add(direction.clone().multiplyScalar(CONFIG.preRingDistance)); // Usar valor del slider
                // Mantener la altura del aro para una transición suave
                afterPoint.y = post.center.y;
                points.push(afterPoint);

                // Crear punto de ascenso a la altura de vuelo para el siguiente segmento
                const exitTransitionPoint = afterPoint.clone();
                exitTransitionPoint.y = CONFIG.height;
                points.push(exitTransitionPoint);
            }

            if (points.length < 2) return null;

            // Crear spline suave con Catmull-Rom
            const curve = new THREE.CatmullRomCurve3(points);
            curve.tension = CONFIG.splineTension; // Usar la tensión configurada
            return curve;
        }

        // Crear curva de vuelo (mantener función original para compatibilidad)
        function createCurve(startId, targetIds) {
            return createSimpleSplinePath(startId, targetIds);
        }

        // --- CLASE FIRE EFFECT ---
        class FireEffect {
            constructor(hoop) {
                this.hoop = hoop; // Reference to the hoop mesh
                this.particles = [];
                this.enabled = false;
                this.particlePool = [];
                this.maxParticles = 200;

                // Create particle geometry and material
                this.particleGeometry = new THREE.SphereGeometry(0.15, 8, 8);

                // Create particles pool for performance
                for (let i = 0; i < this.maxParticles; i++) {
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 1.0,
                        emissive: 0xffaa00,
                        emissiveIntensity: 2.0,
                        roughness: 0.5,
                        metalness: 0.0
                    });
                    const particle = new THREE.Mesh(this.particleGeometry, material);
                    particle.visible = false;
                    scene.add(particle);
                    this.particlePool.push({
                        mesh: particle,
                        velocity: new THREE.Vector3(),
                        life: 0,
                        maxLife: 0,
                        active: false
                    });
                }
            }

            enable() {
                this.enabled = true;
            }

            disable() {
                this.enabled = false;
                // Hide all active particles
                this.particlePool.forEach(p => {
                    p.active = false;
                    p.mesh.visible = false;
                });
            }

            spawnParticle() {
                // Find inactive particle
                const particle = this.particlePool.find(p => !p.active);
                if (!particle) return;

                // Get hoop world position (not local position)
                const hoopPos = new THREE.Vector3();
                this.hoop.getWorldPosition(hoopPos);
                const hoopRotation = this.hoop.rotation.y;

                // Spawn particle at random point on the hoop's circumference
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.5; // Hoop radius
                const offsetX = Math.cos(angle) * radius;
                const offsetZ = Math.sin(angle) * radius;

                // Rotate offset based on hoop rotation
                const rotatedX = offsetX * Math.cos(hoopRotation) - offsetZ * Math.sin(hoopRotation);
                const rotatedZ = offsetX * Math.sin(hoopRotation) + offsetZ * Math.cos(hoopRotation);

                particle.mesh.position.set(
                    hoopPos.x + rotatedX,
                    hoopPos.y + (Math.random() - 0.5) * 0.3, // Slight vertical randomness
                    hoopPos.z + rotatedZ
                );

                // Set initial velocity - upward with outward spread and turbulence
                const spreadForce = 0.5 + Math.random() * 1.5;
                particle.velocity.set(
                    (Math.random() - 0.5) * spreadForce + rotatedX * 0.1,
                    1.5 + Math.random() * 2.0, // Strong upward force
                    (Math.random() - 0.5) * spreadForce + rotatedZ * 0.1
                );

                particle.life = 0;
                particle.maxLife = 0.8 + Math.random() * 0.7; // 0.8 to 1.5 seconds
                particle.active = true;
                particle.mesh.visible = true;

                // Initial color - bright yellow/white
                particle.mesh.material.color.setHex(0xffff88);
                particle.mesh.material.emissive.setHex(0xffff88);
                particle.mesh.material.opacity = 1.0;
                particle.mesh.scale.setScalar(1.0);
            }

            update(deltaTime) {
                if (!this.enabled) return;

                // Spawn new particles - more in night mode for extra glow
                const spawnRate = CONFIG.isNight ? 8 : 5;
                for (let i = 0; i < spawnRate; i++) {
                    this.spawnParticle();
                }

                // Update active particles
                this.particlePool.forEach(particle => {
                    if (!particle.active) return;

                    particle.life += deltaTime;

                    if (particle.life >= particle.maxLife) {
                        particle.active = false;
                        particle.mesh.visible = false;
                        return;
                    }

                    // Calculate life progress (0 to 1)
                    const lifeProgress = particle.life / particle.maxLife;

                    // Update position
                    particle.mesh.position.add(particle.velocity.clone().multiplyScalar(deltaTime));

                    // Apply gravity and turbulence
                    particle.velocity.y -= 0.5 * deltaTime; // Slight gravity
                    particle.velocity.x += (Math.random() - 0.5) * 2.0 * deltaTime; // Turbulence
                    particle.velocity.z += (Math.random() - 0.5) * 2.0 * deltaTime;

                    // Damping
                    particle.velocity.multiplyScalar(0.98);

                    // Color transition: white/yellow -> orange -> red -> dark red/black
                    let color, emissive;
                    if (lifeProgress < 0.2) {
                        // Bright white/yellow core
                        color = new THREE.Color().setHSL(0.15, 1.0, 0.9 - lifeProgress * 2);
                        emissive = color.clone();
                    } else if (lifeProgress < 0.5) {
                        // Orange
                        const t = (lifeProgress - 0.2) / 0.3;
                        color = new THREE.Color().setHSL(0.08 - t * 0.05, 1.0, 0.6 - t * 0.2);
                        emissive = color.clone();
                    } else if (lifeProgress < 0.8) {
                        // Red
                        const t = (lifeProgress - 0.5) / 0.3;
                        color = new THREE.Color().setHSL(0.0, 1.0 - t * 0.3, 0.4 - t * 0.2);
                        emissive = color.clone().multiplyScalar(0.8);
                    } else {
                        // Dark red to black
                        const t = (lifeProgress - 0.8) / 0.2;
                        color = new THREE.Color().setHSL(0.0, 0.7 - t * 0.7, 0.2 - t * 0.2);
                        emissive = color.clone().multiplyScalar(0.3);
                    }

                    particle.mesh.material.color.copy(color);
                    particle.mesh.material.emissive.copy(emissive);
                    particle.mesh.material.emissiveIntensity = CONFIG.isNight ? 3.0 : 2.0;

                    // Fade out and shrink
                    particle.mesh.material.opacity = 1.0 - Math.pow(lifeProgress, 2);
                    particle.mesh.scale.setScalar(1.0 - lifeProgress * 0.5);
                });
            }

            dispose() {
                this.particlePool.forEach(p => {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                });
                this.particlePool = [];
            }
        }

        // --- CLASE DRONE RIVAL MEJORADA ---
        class DroneBall {
            constructor(color, startId) {
                const geo = new THREE.SphereGeometry(0.8, 16, 16);
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.castShadow = true;
                postsGroup.add(this.mesh);

                this.currentStartId = startId;
                this.curve = null;
                this.progress = 0;
                this.speed = CONFIG.speed * (0.8 + Math.random() * 0.4); // Velocidad variable para cada bola
                this.nextStartId = 0;

                this.planNewRoute();
            }

            planNewRoute() {
                if (postsData.length < 2) return;

                const available = postsData.map(p => p.id).filter(id => id !== this.currentStartId);
                const routeIds = shuffle(available);

                this.nextStartId = routeIds[routeIds.length - 1];
                this.curve = createSimpleSplinePath(this.currentStartId, routeIds);
                this.progress = 0;
            }

            update() {
                if (!this.curve) return;

                const len = this.curve.getLength();
                if (len < 1) return;

                // Paso basado en la velocidad individual de la bola
                const step = this.speed / len;
                this.progress += step;

                if (this.progress >= 1) {
                    this.currentStartId = this.nextStartId;
                    this.planNewRoute();
                } else {
                    this.mesh.position.copy(this.curve.getPointAt(this.progress));
                }
            }
        }

        // --- HELPER VISUAL DE SPLINE ---
        function updateSplineHelper() {
            // Limpiar helper anterior
            if (splineHelper) {
                scene.remove(splineHelper);
                splineHelper.geometry.dispose();
                splineHelper.material.dispose();
                splineHelper = null;
            }
            if (splinePoints) {
                splinePoints.forEach(sphere => {
                    scene.remove(sphere);
                    sphere.geometry.dispose();
                    sphere.material.dispose();
                });
                splinePoints = [];
            }

            // Si está activado y hay una curva, crear el helper
            if (CONFIG.showSpline && playerCurve) {
                // Crear línea de la spline
                const points = playerCurve.getPoints(100);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0xff0000,
                    linewidth: 2
                });
                splineHelper = new THREE.Line(geometry, material);
                scene.add(splineHelper);

                // Crear puntos de control
                splinePoints = [];
                const controlPoints = playerCurve.points;
                controlPoints.forEach(point => {
                    const sphereGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.copy(point);
                    scene.add(sphere);
                    splinePoints.push(sphere);
                });
            }
        }

        // --- SISTEMA PRINCIPAL ---

        function startPlayerRound(startId) {
            // Limpiar colores y desactivar todos los efectos de fuego
            postsData.forEach(p => {
                p.mesh.material.color.setHex(0xffaa00); // Amarillo
                p.mesh.material.emissive.setHex(0x000000);
                p.fireEffect.disable(); // Apagar fuego
            });

            const available = postsData.map(p => p.id).filter(id => id !== startId);
            playerPathIndices = shuffle(available);

            if (playerPathIndices.length === 0) {
                updateStatus("ERROR: NO HAY SUFICIENTES POSTES", "#ff0000");
                return;
            }

            // Marcar primer objetivo
            playerCurrentTargetIdx = 0;
            const firstId = playerPathIndices[0];
            postsData[firstId].mesh.material.color.setHex(0x0088ff); // Azul
            postsData[firstId].mesh.material.emissive.setHex(0x004488);
            postsData[firstId].fireEffect.enable(); // Encender fuego en el primer aro azul

            // Generar curva
            playerNextStartId = playerPathIndices[playerPathIndices.length - 1];
            playerCurve = createCurve(startId, playerPathIndices);
            playerProgress = 0;

            // Actualizar helper visual de la spline
            updateSplineHelper();

            updateStatus(`OBJETIVOS: ${playerPathIndices.length}`, "#44aaff");
        }

        function generateWorld() {
            updateStatus("GENERANDO MUNDO...", "#ffff00");

            if (terrainMesh) {
                scene.remove(terrainMesh);
                terrainMesh.geometry.dispose();
            }
            while (postsGroup.children.length > 0) {
                postsGroup.remove(postsGroup.children[0]);
            }
            postsData = [];
            ballsArray = [];

            // Terreno
            const planeGeo = new THREE.PlaneGeometry(CONFIG.terrainSize, CONFIG.terrainSize);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x55aa55, roughness: 0.8 });
            terrainMesh = new THREE.Mesh(planeGeo, planeMat);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.receiveShadow = true;
            terrainMesh.receiveShadow = true;
            terrainMesh.visible = !CONFIG.isNight; // Initial visibility
            scene.add(terrainMesh);

            // Grid para Night Mode
            if (gridHelper) {
                scene.remove(gridHelper);
                gridHelper.geometry.dispose();
            }
            // GridHelper( size, divisions, colorCenterLine, colorGrid )
            gridHelper = new THREE.GridHelper(CONFIG.terrainSize, CONFIG.terrainSize / 10, 0x00ff00, 0x004400);
            gridHelper.position.y = 0.1;
            gridHelper.visible = CONFIG.isNight;
            scene.add(gridHelper);

            // Re-aplicar tema al generar nuevo mundo si estamos en modo noche
            if (CONFIG.isNight) {
                // No necesitamos cambiar material del terreno porque está invisible
                // Pero si quisieramos mantener propiedaes correctas por si acaso:
                terrainMesh.material.color.setHex(0x000000);
            }

            // Postes
            const postGeo = new THREE.CylinderGeometry(0.2, 0.2, 10, 8);
            const ringGeo = new THREE.TorusGeometry(1.5, 0.15, 8, 24);
            // postMat is now global

            // Re-aplicar tema al material de los postes
            if (CONFIG.isNight) {
                postMat.color.setHex(0x111111);
                postMat.emissive.setHex(0x4400cc);
                postMat.emissiveIntensity = 0.8;
            }

            const ringMatBase = new THREE.MeshStandardMaterial({ color: 0xffaa00 });

            // Algoritmo de distribución con distancia mínima
            const minDistance = 10; // Distancia mínima entre postes en metros
            const maxRadius = CONFIG.terrainSize * 0.45; // 45% del tamaño del terreno para evitar bordes
            const postPositions = [];

            for (let i = 0; i < CONFIG.numPosts; i++) {
                let x, z;
                let attempts = 0;
                const maxAttempts = 100;

                // Intentar encontrar una posición válida
                do {
                    const radius = Math.random() * maxRadius;
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                    attempts++;
                } while (attempts < maxAttempts && postPositions.some(pos => {
                    const distance = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    return distance < minDistance;
                }));

                // Si no se encontró una posición válida, usar la última generada
                postPositions.push({ x, z });
                const h = 1 + Math.random() * (CONFIG.maxPostHeight - 1); // Altura aleatoria entre 1 y maxPostHeight metros

                const post = new THREE.Mesh(postGeo, postMat);
                post.scale.y = h / 10;
                post.position.set(x, h / 2, z);
                post.castShadow = true;
                postsGroup.add(post);

                const ring = new THREE.Mesh(ringGeo, ringMatBase.clone());
                const ringY = h + 1.5 + 0.15;
                ring.position.set(x, ringY, z);
                ring.rotation.y = Math.random() * Math.PI * 2;
                postsGroup.add(ring);

                // Calcular vector normal que apunta en la dirección "hacia adelante" del aro
                // El aro está en el plano XY, así que rotamos un vector en el plano XZ
                const angle = ring.rotation.y;
                const normal = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle)).normalize();

                const center = new THREE.Vector3(x, ringY, z);

                // Create fire effect for this hoop
                const fireEffect = new FireEffect(ring);

                postsData.push({
                    id: i,
                    center: center,
                    normal: normal,
                    entry: center.clone().add(normal.clone().multiplyScalar(4)),
                    exit: center.clone().sub(normal.clone().multiplyScalar(4)),
                    mesh: ring,
                    fireEffect: fireEffect
                });
            }

            if (postsData.length > 1) {
                const startNode = postsData[0];
                const startPos = startNode.center.clone().sub(startNode.normal.clone().multiplyScalar(15));
                startPos.y = CONFIG.height; // Usar la altura de vuelo configurada, no la altura del aro
                camera.position.copy(startPos);
                camera.lookAt(startNode.center);

                startPlayerRound(0);
            }

            for (let i = 0; i < CONFIG.numBalls; i++) {
                const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
                const startId = (i + 1) % CONFIG.numPosts;
                ballsArray.push(new DroneBall(color, startId));
            }
        }

        // --- FUNCIÓN PARA CALCULAR FPS ---
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;

            // Actualizar FPS cada segundo
            if (deltaTime >= 1000) {
                fps = Math.round((frameCount * 1000) / deltaTime);
                document.getElementById('fps-value').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // --- LOOP DE ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);

            if (playerCurve) {
                const len = playerCurve.getLength();
                if (len > 1) {
                    const step = CONFIG.speed / len;
                    playerProgress += step;

                    if (playerProgress >= 1) {
                        startPlayerRound(playerNextStartId);
                    } else {
                        // Movimiento
                        const pos = playerCurve.getPointAt(playerProgress);
                        camera.position.copy(pos);

                        // Sistema de lookAt con transición suave
                        let lookAtTarget = new THREE.Vector3();

                        if (lookAtTransition.active) {
                            // Transición activa: lerp entre look front y próximo objetivo
                            const elapsed = performance.now() - lookAtTransition.startTime;
                            const t = Math.min(elapsed / lookAtTransition.duration, 1.0);

                            // DEBUG: Ver valores del lerp


                            // Lerp suave entre startTarget (front) y endTarget (próximo aro)
                            lookAtTarget.lerpVectors(lookAtTransition.startTarget, lookAtTransition.endTarget, t);

                            // Desactivar transición cuando se completa
                            if (t >= 1.0) {

                                lookAtTransition.active = false;
                            }
                        } else {
                            // Comportamiento normal: mirar al próximo aro objetivo
                            if (playerCurrentTargetIdx < playerPathIndices.length) {
                                const targetId = playerPathIndices[playerCurrentTargetIdx];
                                const target = postsData[targetId];
                                lookAtTarget.copy(target.center);
                            } else {
                                // Si no hay más objetivos, mirar hacia adelante en la curva
                                const lookAheadDistance = 3.0;
                                const lookAtT = Math.min(playerProgress + (lookAheadDistance / len), 1);
                                lookAtTarget.copy(playerCurve.getPointAt(lookAtT));
                            }
                        }

                        camera.lookAt(lookAtTarget);

                        if (playerCurrentTargetIdx < playerPathIndices.length) {
                            const targetId = playerPathIndices[playerCurrentTargetIdx];
                            const target = postsData[targetId];

                            // Detectar cuando la cámara pasa por el aro
                            const distanceToCenter = camera.position.distanceTo(target.center);

                            // Si la cámara está muy cerca del centro del aro (menos de 1.5 metros)
                            if (distanceToCenter < 1.5) {


                                // Marcar aro actual como pasado (rojo) y apagar fuego
                                target.mesh.material.color.setHex(0xff0000);
                                target.mesh.material.emissive.setHex(0x550000);
                                target.fireEffect.disable(); // Apagar fuego cuando pasa a rojo

                                // Avanzar al siguiente aro
                                playerCurrentTargetIdx++;
                                const left = playerPathIndices.length - playerCurrentTargetIdx;
                                updateStatus(`PENDIENTES: ${left}`, "#44aaff");

                                // Iniciar transición suave de lookAt
                                lookAtTransition.active = true;
                                lookAtTransition.startTime = performance.now();

                                // Target inicial: proyectar 20 metros adelante en la dirección actual de la cámara
                                // Esto evita el "giro" de 180 grados al pasar por el centro del aro anterior
                                const forward = new THREE.Vector3();
                                camera.getWorldDirection(forward);
                                lookAtTransition.startTarget.copy(camera.position).add(forward.multiplyScalar(20));

                                // Target final: centro del próximo aro
                                if (playerCurrentTargetIdx < playerPathIndices.length) {
                                    const nextId = playerPathIndices[playerCurrentTargetIdx];
                                    lookAtTransition.endTarget.copy(postsData[nextId].center);

                                }

                                // Marcar el siguiente aro como objetivo (azul) y encender fuego
                                if (playerCurrentTargetIdx < playerPathIndices.length) {
                                    const nextId = playerPathIndices[playerCurrentTargetIdx];
                                    postsData[nextId].mesh.material.color.setHex(0x0088ff);
                                    postsData[nextId].mesh.material.emissive.setHex(0x004488);
                                    postsData[nextId].fireEffect.enable(); // Encender fuego en el siguiente aro azul
                                } else {
                                    // Todos los aros pasados
                                    updateStatus("¡VUELTA TERMINADA!", "#00ff00");
                                }
                            }
                        }
                    }
                }
            }

            ballsArray.forEach(b => {
                b.update();
                // En modo noche, asegurar que el brillo sigue el color
                if (CONFIG.isNight) {
                    b.mesh.material.emissive.copy(b.mesh.material.color);
                }
            });

            // Calcular deltaTime para animación de partículas
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000; // Convertir a segundos
            lastFrameTime = currentTime;

            // Actualizar efectos de fuego
            postsData.forEach(p => {
                p.fireEffect.update(deltaTime);
            });

            // Actualizar contador de FPS
            updateFPS();

            renderer.render(scene, camera);
        }

        // --- EVENTOS UI ---
        document.getElementById('sl-speed').oninput = (e) => {
            CONFIG.speed = parseFloat(e.target.value);
            document.getElementById('v-speed').innerText = CONFIG.speed;
        };
        document.getElementById('sl-height').oninput = (e) => {
            CONFIG.height = parseFloat(e.target.value);
            document.getElementById('v-height').innerText = CONFIG.height;
        };

        let timer;
        const triggerReload = () => {
            clearTimeout(timer);
            timer = setTimeout(generateWorld, 500);
        };

        document.getElementById('sl-terrain').oninput = (e) => {
            CONFIG.terrainSize = parseInt(e.target.value);
            document.getElementById('v-terrain').innerText = CONFIG.terrainSize;
            triggerReload();
        };
        document.getElementById('sl-posts').oninput = (e) => {
            CONFIG.numPosts = parseInt(e.target.value);
            document.getElementById('v-posts').innerText = CONFIG.numPosts;
            triggerReload();
        };
        document.getElementById('sl-balls').oninput = (e) => {
            CONFIG.numBalls = parseInt(e.target.value);
            document.getElementById('v-balls').innerText = CONFIG.numBalls;
            triggerReload();
        };
        document.getElementById('sl-preRingDistance').oninput = (e) => {
            CONFIG.preRingDistance = parseInt(e.target.value);
            document.getElementById('v-preRingDistance').innerText = CONFIG.preRingDistance;
        };
        document.getElementById('sl-maxPostHeight').oninput = (e) => {
            CONFIG.maxPostHeight = parseFloat(e.target.value);
            document.getElementById('v-maxPostHeight').innerText = CONFIG.maxPostHeight;
            triggerReload(); // Resetea el sistema cuando cambia la altura máxima
        };

        // Evento Modo Nocturno
        document.getElementById('chk-theme').onchange = (e) => {
            CONFIG.isNight = e.target.checked;
            updateTheme();
        };

        // Evento Mostrar Spline
        document.getElementById('chk-spline').onchange = (e) => {
            CONFIG.showSpline = e.target.checked;
            updateSplineHelper();
        };

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };

        generateWorld();

        // Inicializar valores de display
        document.getElementById('v-preRingDistance').innerText = CONFIG.preRingDistance;
        document.getElementById('v-maxPostHeight').innerText = CONFIG.maxPostHeight;

        animate();

    </script>
</body>

</html>